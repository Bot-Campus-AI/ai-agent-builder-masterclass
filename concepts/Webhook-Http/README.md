
---

## Demo: **Webhook ‚Üí HTTP Request**

---

## üéØ **Objective**

Show how **dynamic user input** can be captured in real time through a **Webhook** and then automatically passed to an **HTTP Request** node, which calls an external API. You should walk away with a clear understanding that n8n workflows can adapt to **live incoming data**.

---

## ü™ú **Step-by-Step Guide**

### **Step 1: Add a Webhook Node**

1. Open n8n and create a **new workflow**.
2. Drag in a **Webhook Node**.
3. Configure:

   * **HTTP Method** ‚Üí POST
   * **Path** ‚Üí `/lead-capture` (or any simple name).
4. Save the workflow ‚Üí Copy the **unique Webhook URL** generated by n8n.

---

### **Step 2: Send Data to the Webhook**

1. Open **Postman** (or any API client).
2. Make a **POST request** to the Webhook URL with this JSON body:

```json
{
  "status": "pending",
  "score": 72,
  "fullName": "Ali Khan"
}
```

3. Run the workflow ‚Üí The Webhook node will capture this JSON and display it as output in n8n.

‚úÖ **At this point:** students see that the workflow can already ‚Äúlisten‚Äù and accept any data they send.

---

### **Step 3: Add HTTP Request Node**

1. Connect **Webhook ‚Üí HTTP Request**.
2. Configure HTTP Request node:

   * **Method** ‚Üí GET
   * **URL** ‚Üí `https://httpbin.org/get`
   * Add **Query Parameters**:

     * `status` ‚Üí `={{$json["status"]}}`
     * `score` ‚Üí `={{$json["score"]}}`
     * `fullName` ‚Üí `={{$json["fullName"]}}`

‚úÖ Now, instead of fixed values, the HTTP Request node pulls the **live incoming values** from the Webhook.

---

### **Step 4: Run the Workflow Again with Different Data**

1. Send a new POST request with different values:

```json
{
  "status": "active",
  "score": 95,
  "fullName": "Sara Ahmed"
}
```

2. Execute the workflow.

---


## **Step 5: Understand the HTTP Request Output (Elaborated)**

### **5.1 Create the HTTP Request node**

1. From your **Webhook** node, drag a connection to a new **HTTP Request** node.
2. Select the HTTP Request node to open its settings.

### **5.2 Add the HTTPBIN URL**

1. **Method**: `GET`
2. **URL**: `https://httpbin.org/get`

### **5.3 Map dynamic query parameters from the Webhook**

1. Expand **Query Parameters** ‚Üí **Add Parameter** for each field:

   * **Name**: `status` ‚Üí **Value (Expression)**: `={{ $json["status"] }}`
   * **Name**: `score` ‚Üí **Value (Expression)**: `={{ $json["score"] }}`
   * **Name**: `fullName` ‚Üí **Value (Expression)**: `={{ $json["fullName"] }}`

### **5.4 Execute with live data**

1. **Activate/listen** on the Webhook (or keep the workflow running).
2. Send a **POST** again to your Webhook URL with JSON, e.g.:

   ```json
   { "status": "active", "score": 95, "fullName": "Sara Ahmed" }
   ```
3. n8n will run: **Webhook ‚Üí HTTP Request**.
4. Open the **HTTP Request** node‚Äôs execution result.

### **5.5 Read the HTTP node output like a pro**

You‚Äôll see a JSON response similar to:

```json
{
  "args": {
    "status": "active",
    "score": "95",
    "fullName": "Sara Ahmed"
  },
  "headers": { "...": "..." },
  "url": "https://httpbin.org/get?status=active&score=95&fullName=Sara%20Ahmed"
}
```

* **args** ‚Üí The exact **query parameters** you sent. This proves your Webhook data flowed into the request.
* **url** ‚Üí The final URL with **URL-encoded** values (spaces ‚Üí `%20`).
* **headers** ‚Üí Meta sent with the request (user-agent, accept, etc.).
* **Note on types**: Query strings are **strings**, so numbers (e.g., `95`) appear as `"95"`.

### **5.6 (Optional) Quick experiments to cement learning**

* **Change input** at the Webhook (new name/score) ‚Üí re-POST ‚Üí watch `args` update instantly.
* **Switch to POST body**:

  * Method: `POST`, URL: `https://httpbin.org/post`
  * **Body** ‚Üí **JSON**:

    ```json
    { "status": "active", "score": 95, "fullName": "Sara Ahmed" }
    ```
  * Inspect response under `body.json` (you‚Äôll see native types, e.g., `95` as a number).

---


